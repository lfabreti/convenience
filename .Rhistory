if( psrf_windows[[i]]$psrf[j] > max_psrf ){
stop("Try running your MCMC for more iterations")
}
}
}
# check stats between runs
stats_runs <- statsContParam(my_runs)
count <- 0
for (i in 1:length(stats_runs)) {
for (j in 1:length(stats_runs[[1]])){
for (k in 1:nrow(stats_runs[[1]][1])) {
if (stats_runs[[i]][[j]][k] > min_stats){
name_stats <- c(name_stats, (rownames(stats_runs[[i]])[k]))
}
}
}
}
if (length(name_stats)>0){
print(paste("The following parameters failed to converge:", name_stats))
}
#check psrf between runs
psrf_runs <- psrfContParams(my_runs)
for (i in 1:(length(psrf_runs[[1]])/2)) {
if( psrf_runs[[1]][i] > max_psrf){
print(psrf_runs[[1]][i])
name_psrf <- c(name_psrf, (rownames(psrf_runs[[1]])[i]))
print( rownames(psrf_runs[[1]])[i] )
}
}
if (length(name_psrf)>0){
print(paste("The following parameters failed in PSRF:", name_psrf))
}
}
checkConvergence <- function(runs, burnin = 0.1, min_split = 0.05, percent = 0.01, min_stats = 0.5, max_psrf = 1.05){
# load the mcmc output
my_runs <- loadFiles(runs, burnin, format = "revbayes")
#initializing a counter
count = 0
name_stats <- vector("list", length = 0)
name_psrf <- vector("list", length = 0)
## If we have tree files, we check split freq ##
if( length(my_runs[[1]]$trees) > 0 ){ # if we have tree files, we check split freq
## First we check if the runs are ok, by comparing windows of the same run ##
vec_splits_windows <- splitFreq(my_runs, windows = T)
for (i in 1:length(vec_splits_windows)) {
if ( vec_splits_windows[i] > min_split ){
stop("Try running your MCMC for more iterations")
}
}
## If the runs are ok, we compare the split freq between them ##
vec_split_runs <- splitFreq(my_runs)
for (i in 1:length(vec_split_runs)) {
if(vec_split_runs[1] < min_split){
count <- count + 1
}
}
print(paste((count/length(vec_split_runs))*100,"% of the splits are above the minimum value"))
}
## If we have log files, we check the cont parameters ##
if( length(my_runs[[1]]$ptable) > 0 ){ # if we have log files, we check the cont parameters
# check if min ESS is achieved for all cont parameters
min_ess <- minESS(percent)
ess_runs <- essContParam(runs)
for (i in 1:length(ess_runs)) {
for (j in 1:length(ess_runs[[1]])) {
if (ess_runs[[i]][j] < min_ess){
stop("Try running your MCMC for more iterations")
}
}
}
# check if std error is within 1% of the 95% interval
std_error <- stderrContParam(runs)
min_std_error <- stderrMin(runs)
comp <- mapply("-", std_error,min_std_error)
for (i in 1:length(comp)) {
for (j in 1:length(comp[[1]])) {
if (comp[[i]][j] < 0){
stop("Try running your MCMC for more iterations")
}
}
}
#check if stats within runs are ok
stats_values <- statsContParam(my_runs, windows = TRUE)
for (i in 1:length(stats_values)) {
for (j in 1:length(stats_values[[1]])){
for (k in 1:nrow(stats_values[[1]][1])) {
if (stats_values[[i]][[j]][k] > min_stats){
stop("Try running your MCMC for more iterations")
}
}
}
}
#check if psrf within runs is ok
psrf_windows <- psrfContParams(my_runs, windows = TRUE)
for (i in 1:length(psrf_windows)) {
for (j in 1:(length(psrf_windows[[1]]$psrf)/2)){
if( psrf_windows[[i]]$psrf[j] > max_psrf ){
stop("Try running your MCMC for more iterations")
}
}
}
# check stats between runs
stats_runs <- statsContParam(my_runs)
count <- 0
for (i in 1:length(stats_runs)) {
for (j in 1:length(stats_runs[[1]])){
for (k in 1:nrow(stats_runs[[1]][1])) {
if (stats_runs[[i]][[j]][k] > min_stats){
name_stats <- c(name_stats, (rownames(stats_runs[[i]])[k]))
}
}
}
}
if (length(name_stats)>0){
print(paste("The following parameters failed to converge:", name_stats))
}
#check psrf between runs
psrf_runs <- psrfContParams(my_runs)
for (i in 1:(length(psrf_runs[[1]])/2)) {
if( psrf_runs[[1]][i] > max_psrf){
print(psrf_runs[[1]][i])
name_psrf <- c(name_psrf, (rownames(psrf_runs[[1]])[i]))
print( rownames(psrf_runs[[1]])[i] )
}
}
if (length(name_psrf)>0){
print(paste("The following parameters failed in PSRF:", name_psrf))
}
}
}
source('~/Projects/convenience/R/checkConvergence.R')
checkConvergence("example/2_runs/")
library(convenience)
checkConvergence("example/2_runs/")
checkConvergence("example/2_runs/")
source('~/Projects/convenience/R/checkConvergence.R')
checkConvergence("example/2_runs/")
runs <- "~/Projects/convenience/example/2_runs/"
# load the mcmc output
my_runs <- loadFiles(runs, burnin, format = "revbayes")
burnin = 0.1
# load the mcmc output
my_runs <- loadFiles(runs, burnin, format = "revbayes")
ess_runs <- essContParam(my_runs)
source('~/Projects/convenience/R/checkConvergence.R')
checkConvergence("example/2_runs/")
# check if std error is within 1% of the 95% interval
std_error <- stderrContParam(my_runs)
min_std_error <- stderrMin(my_runs)
source('~/Projects/convenience/R/checkConvergence.R')
checkConvergence("example/2_runs/")
?suppressWarnings
# load the mcmc output
my_runs <- loadFiles(runs, burnin, format = "revbayes", suppressWarnings())
# load the mcmc output
my_runs <- loadFiles(runs, burnin, format = "revbayes", suppressWarnings(expr))
# load the mcmc output
my_runs <- loadFiles(runs, burnin, format = "revbayes", options(warn = -1))
source('~/Projects/convenience/R/checkConvergence.R')
# load the mcmc output
my_runs <- loadFiles(runs, burnin, format = "revbayes", options(warn = -1))
checkConvergence("example/2_runs/")
source('~/Projects/convenience/R/loadFiles.R')
loadFiles <- function(path, format="revbayes", burnin = 0.1, tree_name =  "psi", log_ext = "*.log", tree_ext="*.trees", options(warn = -1)){
output <- list()
files <- list.files(path, recursive=F)
files <- files[ grepl("*run*", files) ]
logFiles <- files[ grepl(log_ext, files) ]
treeFiles <- files[ grepl(tree_ext, files) ]
if ( length(logFiles) == 0 & length(treeFiles) == 0 ){
stop("No files to read")
}
else if ( length(logFiles) > 0 & length(treeFiles) == 0 ){
output <- list()
for (i in 1:length(logFiles)){
output[[i]] <- readTrace(logFiles[i], burnin = burnin)
}
}
else{
all_vecs <- vector("list", length = 0)
files <- list.files(path, pattern = "*trees")
for(i in 1:length(files)){
all_vecs[[i]] <- paste("run_", i)
}
vec <- unlist(all_vecs)
output <- load.multi(path , format = format, labels=vec) # add burnin
# exclude combined files
count_sizes <- vector("double", length=0)
for (i in 1:length(output)){
count_sizes <- c(count_sizes, length(output[[i]]$trees))
}
mean <- mean(count_sizes)
for (i in 1:length(output)) {
if( (length(output[[i]]$trees)) > mean ){
output <- output[-i]
}
}
#burnin
if (burnin >= length(output[[1]]$trees)) stop("Burnin larger than iterations in file")
for (i in 1:length(output)) {
if (burnin >= 1) {
output[[i]]$trees <- output[[i]]$trees[(burnin+1):(length(output[[i]]$trees))]
output[[i]]$ptable <- output[[i]]$ptable[(burnin+1):(nrow(output[[i]]$ptable)),]
} else if (burnin < 1 & burnin > 0) { #not working
discard <- ceiling(burnin*(length(output[[i]]$trees)))
output[[i]]$trees <- output[[i]]$trees[(discard+1):(length(output[[i]]$trees))]
output[[i]]$ptable <- output[[i]]$ptable[(discard+1):(nrow(output[[i]]$ptable)),]
} else if (burnin == 0) {
output[[i]] <- output[[1]]
} else {
stop("What have you done?")
}
}
# exclude logs for when there is only tree files
if (length(logFiles) == 0){
for(i in 1:length(output)){
output[[i]]$ptable <- vector("list", length = 0)
}
}
}
return(output)
}
source('~/Projects/convenience/R/loadFiles.R')
loadFiles("~/Projects/convenience/example/2_runs/")
library(convenience)
checkConvergence("example/2_runs/")
source('~/Projects/convenience/R/checkConvergence.R')
source('~/Projects/convenience/R/loadFiles.R')
checkConvergence("example/2_runs/")
checkConvergence("example/4_runs/")
burnin = 0.1
min_split = 0.05
percent = 0.01
min_stats = 0.5
max_psrf = 1.05
# check if min ESS is achieved for all cont parameters
min_ess <- minESS(percent)
ess_runs <- essContParam(my_runs)
length(ess_runs)
ess_runs
rownames(ess_runs)
# check if std error is within 1% of the 95% interval
std_error <- stderrContParam(my_runs)
min_std_error <- stderrMin(my_runs)
comp <- mapply("-", std_error,min_std_error)
comp
std_error
min_std_error
source('~/Projects/convenience/R/checkConvergence.R')
checkConvergence("example/4_runs/")
comp_1 <- mapply("-", min_std_error, std_error)
comp_1
std_error
min_std_error
source('~/Projects/convenience/R/checkConvergence.R')
checkConvergence("example/4_runs/")
#check if stats within runs are ok
stats_values <- statsContParam(my_runs, windows = TRUE)
stats_values
#check if psrf within runs is ok
psrf_windows <- psrfContParams(my_runs, windows = TRUE)
for (i in 1:length(psrf_windows)) {
for (j in 1:(length(psrf_windows[[1]]$psrf)/2)){
if( psrf_windows[[i]]$psrf[j] > max_psrf ){
stop("Try running your MCMC for more iterations, psrf did not converge within runs")
}
}
}
# check stats between runs
stats_runs <- statsContParam(my_runs)
count <- 0
for (i in 1:length(stats_runs)) {
for (j in 1:length(stats_runs[[1]])){
for (k in 1:nrow(stats_runs[[1]][1])) {
if (stats_runs[[i]][[j]][k] > min_stats){
name_stats <- c(name_stats, (rownames(stats_runs[[i]])[k]))
}
}
}
}
if (length(name_stats)>0){
print(paste("The following parameters failed to converge:", name_stats))
}
#check psrf between runs
psrf_runs <- psrfContParams(my_runs)
for (i in 1:(length(psrf_runs[[1]])/2)) {
if( psrf_runs[[1]][i] > max_psrf){
print(psrf_runs[[1]][i])
name_psrf <- c(name_psrf, (rownames(psrf_runs[[1]])[i]))
print( rownames(psrf_runs[[1]])[i] )
}
}
if (length(name_psrf)>0){
print(paste("The following parameters failed in PSRF:", name_psrf))
}
if( length(my_runs[[1]]$ptable) > 0 ){ # if we have log files, we check the cont parameters
# check if min ESS is achieved for all cont parameters
min_ess <- minESS(percent)
ess_runs <- essContParam(my_runs)
for (i in 1:length(ess_runs)) {
for (j in 1:length(ess_runs[[1]])) {
if (ess_runs[[i]][j] < min_ess){
stop("Try running your MCMC for more iterations, ess not achieved for all parameters")
}
}
}
# check if std error is within 1% of the 95% interval
std_error <- stderrContParam(my_runs)
max_std_error <- stderrMin(my_runs)
comp <- mapply("-", max_std_error, std_error)
for (i in 1:length(comp)) {
for (j in 1:length(comp[[1]])) {
if (comp[[i]][j] < 0){
stop("Try running your MCMC for more iterations, standard error of the mean is too large")
}
}
}
#check if stats within runs are ok
stats_values <- statsContParam(my_runs, windows = TRUE)
for (i in 1:length(stats_values)) {
for (j in 1:length(stats_values[[1]])){
for (k in 1:nrow(stats_values[[1]][1])) {
if (stats_values[[i]][[j]][k] > min_stats){
stop("Try running your MCMC for more iterations, parameters did not converge within runs")
}
}
}
}
#check if psrf within runs is ok
psrf_windows <- psrfContParams(my_runs, windows = TRUE)
for (i in 1:length(psrf_windows)) {
for (j in 1:(length(psrf_windows[[1]]$psrf)/2)){
if( psrf_windows[[i]]$psrf[j] > max_psrf ){
stop("Try running your MCMC for more iterations, psrf did not converge within runs")
}
}
}
# check stats between runs
stats_runs <- statsContParam(my_runs)
count <- 0
for (i in 1:length(stats_runs)) {
for (j in 1:length(stats_runs[[1]])){
for (k in 1:nrow(stats_runs[[1]][1])) {
if (stats_runs[[i]][[j]][k] > min_stats){
name_stats <- c(name_stats, (rownames(stats_runs[[i]])[k]))
}
}
}
}
if (length(name_stats)>0){
print(paste("The following parameters failed to converge:", name_stats))
}
#check psrf between runs
psrf_runs <- psrfContParams(my_runs)
for (i in 1:(length(psrf_runs[[1]])/2)) {
if( psrf_runs[[1]][i] > max_psrf){
print(psrf_runs[[1]][i])
name_psrf <- c(name_psrf, (rownames(psrf_runs[[1]])[i]))
print( rownames(psrf_runs[[1]])[i] )
}
}
if (length(name_psrf)>0){
print(paste("The following parameters failed in PSRF:", name_psrf))
}
}
# check stats between runs
stats_runs <- statsContParam(my_runs)
stats_runs
essContParam(my_runs)
list_df <- list()
all_df <- vector("list", length = 0)
for (i in 1:length(runs)) {
#get the cont_param for each run
all_df[[i]] <- getInfo(runs, i, namesToExclude)
}
namesToExclude = "bl|Iteration|Likelihood|Posterior|Prior"
for (i in 1:length(runs)) {
#get the cont_param for each run
all_df[[i]] <- getInfo(runs, i, namesToExclude)
}
vecAll <- vector("list", length = 0)
all_df
all_df[[1]]
for (df1 in 1:(length(all_df)-1)){
vecStats <- vector(length = 0)
vecStats <- c(vecStats,calcRelativeDiff(all_df[[df1]],all_df[[df1+1]],mean))
vecStats <- c(vecStats,calcRelativeDiff(all_df[[df1]],all_df[[df1+1]],median))
vecStats <- c(vecStats,calcRelativeDiff(all_df[[df1]],all_df[[df1+1]],sd))
vecStats <- c(vecStats,calcRelativeDiff(all_df[[df1]],all_df[[df1+1]],quants))
vecAll <- c(vecAll, vecStats)
}
runs
runs <- my_runs
list_df <- list()
all_df <- vector("list", length = 0)
for (i in 1:length(runs)) {
#get the cont_param for each run
all_df[[i]] <- getInfo(runs, i, namesToExclude)
}
all_df
all_df[[1]]$alpha
mean(all_df[[1]]$alpha)
mean(all_df[[2]]$alpha)
mean(all_df[[1]]$sr.1.)
mean(all_df[[2]]$sr.1.)
stats_runs
setwd("example/2_runs/")
checkConvergence(".")
library(convenience)
checkConvergence("~/Projects/Allison_runs/")
library(convenience)
checkConvergence("~/Projects/Allison_runs/")
path <- "~/Projects/Allison_runs/"
files <- list.files(path, recursive=F)
files <- files[ grepl("*run*|*joint*", files) ]
files
log_ext = "*.log"
tree_ext="*.trees"
logFiles <- files[ grepl(log_ext, files) ]
treeFiles <- files[ grepl(tree_ext, files) ]
logFiles
treeFiles
library(convenience)
checkConvergence("~/Projects/Allison_runs/")
source('~/Projects/convenience/R/loadFiles.R')
checkConvergence("~/Projects/Allison_runs/")
ess_runs
source('~/Projects/convenience/R/checkConvergence.R')
checkConvergence("~/Projects/Allison_runs/")
source('~/Projects/convenience/R/checkConvergence.R')
checkConvergence("~/Projects/Allison_runs/")
source('~/Projects/convenience/R/checkConvergence.R')
checkConvergence("~/Projects/Allison_runs/")
source('~/Projects/convenience/R/checkConvergence.R')
checkConvergence("~/Projects/Allison_runs/")
library(convenience)
checkConvergence("~/Projects/Allison_runs/")
debugSource('~/Projects/convenience/R/checkConvergence.R')
library(convenience)
my_runs <- loadFiles("~/Projects/convenience/example/2_runs/")
essContParam(my_runs)
psrfContParams(my_runs, windows = T)
psrfContParams(my_runs, windows = F)
stderrContParam(my_runs)
statsContParam(my_runs, windows = T)
statsContParam(my_runs, windows = F)
splitFreq(my_runs, windows = T)
splitFreq(my_runs, windows = F)
library(convenience)
my_runs <- loadFiles("~/Projects/convenience/example/2_runs/")
devtools::load_all("~/Projects/convenience")
checkConvergence("~/Projects/convenience/example/2_runs/", burnin = 0.1, min_split = 0.05, percent = 0.01, min_stats = 0.5, max_psrf = 1.05)
library(convenience)
library(convenience)
checkConvergence("~/Projects/convenience/example/2_runs/", burnin = 0.1, min_split = 0.05, percent = 0.01, min_stats = 0.5, max_psrf = 1.05)
library(convenience)
checkConvergence("~/Projects/convenience/example/2_runs/", burnin = 0.1, min_split = 0.05, percent = 0.01, min_stats = 0.5, max_psrf = 1.05)
library(devtools)
install_github("lfabreti/convenience")
devtools::load_all(".")
checkConvergence("~/Projects/convenience/example/2_runs/", burnin = 0.1, min_split = 0.05, percent = 0.01, min_stats = 0.5, max_psrf = 1.05)
my_runs <- loadFiles("~/Projects/convenience/example/2_runs/")
essContParam(my_runs)
my_runs
psrfContParams(my_runs, windows = T)
psrfContParams(my_runs, windows = F)
stderrContParam(my_runs)
statsContParam(my_runs, windows = T)
statsContParam(my_runs, windows = F)
splitFreq(my_runs, windows = T)
splitFreq(my_runs, windows = F)
my_runs <- loadFiles("~/Projects/Allison_runs/")
essContParam(my_runs)
checkConvergence("~/Projects/Allison_runs/")
checkConvergence("~/Projects/Allison_runs/", percent = 0.1)
?loadFiles
?load.multi
my_runs
runs <- my_runs
all_df <- vector("list", length = 0)
for (i in 1:length(runs)){
x <- getInfo(runs, i, trees = TRUE)
cladefreqs <- clade.freq.named(x, start = 1, end = length(x))
all_df[[i]] <- cladefreqs
}
for (r1 in 1:(length(all_df)-1)){
#print(r1)
for (z in 1:length(all_df[[r1]]$cladenames)){
for (j in 1:length(all_df[[r1+1]]$cladenames)){
if( as.character(all_df[[r1]]$cladenames[z]) == as.character(all_df[[r1+1]]$cladenames[j]) ){
vecSplits <- c ( vecSplits, ( abs (all_df[[r1]]$cladefreqs[z] - all_df[[r1+1]]$cladefreqs[j] ) ) )
}
}
}
}
vecSplits <- vector(length = 0)
all_df <- vector("list", length = 0)
for (i in 1:length(runs)){
x <- getInfo(runs, i, trees = TRUE)
cladefreqs <- clade.freq.named(x, start = 1, end = length(x))
all_df[[i]] <- cladefreqs
}
all_df
all_df[[1]]
all_df[[1]][1]
all_df[[1]]$cladefreqs
all_df[[1]]$cladefreqs[1]
i=1
x <- getInfo(runs, i, trees = TRUE)
cladefreqs <- clade.freq.named(x, start = 1, end = length(x))
cladefreqs
splitFreq(my_runs)
